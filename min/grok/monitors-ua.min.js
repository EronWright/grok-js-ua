(function(global){var GROK=global.GROK,DEFAULT_POLL_INTERVAL=[3e3,3e6],DEFAULT_TIMEOUT=60,DEFAULT_POLL_INCREMENT=function(i){return i*2},ROW_ID="ROWID",ANY="any";function findIndex(obj,iterator,context){var result;Array.prototype.some.call(obj,function(value,index,list){if(iterator.call(context,value,index,list)){result=index;return true}});return result}function extractLastRowId(output){return output.data[output.data.length-1][output.names.indexOf(ROW_ID)]}function Monitor(poller,opts){opts=opts||{};this._poller=poller;if(typeof opts.interval==="undefined"){this._interval=DEFAULT_POLL_INTERVAL}else if(typeof opts.interval==="number"){this._interval=[opts.interval,opts.interval*10]}else{this._interval=opts.interval}this._increment=opts.increment||DEFAULT_POLL_INCREMENT;this._timeout=opts.timeout||DEFAULT_TIMEOUT;this._currentInterval=this._interval[0];this._debug=opts.debug;this._pollIntervalId=-1;this._pollListeners=[];this._doneListeners=[];this._errorListeners=[];this._done=false}Monitor.prototype.onPoll=function(fn){this._pollListeners.push(fn);return this};Monitor.prototype.onDone=function(fn){this._doneListeners.push(fn);return this};Monitor.prototype.onError=function(fn){this._errorListeners.push(fn);return this};Monitor.prototype._fire=function(evt,payload){var count=0;if(evt==="done"){this._done=true}this["_"+evt+"Listeners"].forEach(function(listener){count++;listener(payload)});this._print("Monitor called "+count+" "+evt+" listeners")};Monitor.prototype.start=function(){this._startTime=(new Date).getTime();this._print("Monitor starting");this._pollAt(this._currentInterval);return this};Monitor.prototype._pollAt=function(interval){var me=this,activePoll=false;if(this._pollIntervalId){clearInterval(this._pollIntervalId)}me._print("Polling at "+interval);this._pollIntervalId=setInterval(function(){if(activePoll){return}if(me._done){clearInterval(me._pollIntervalId);return}activePoll=true;me._print("Monitor polling...");me._poller(function(pollResult,newDataReceived){me._print("Monitor received poll result");me._print("new data recieved? "+new Boolean(newDataReceived));if(!newDataReceived){if(me._currentInterval!==me._interval[1]){me._currentInterval=Math.min(me._increment(me._currentInterval),me._interval[1]);me._pollAt(me._currentInterval)}}else{if(me._currentInterval!==me._interval[0]){me._currentInterval=me._interval[0];me._print("Resetting poll interval to "+me._currentInterval);me._pollAt(me._currentInterval)}}if(!me._done){me._fire("poll",pollResult)}activePoll=false})},interval)};Monitor.prototype.stop=function(){var duration=(new Date).getTime()-this._startTime;this._print("Monitor stopping");clearInterval(this._pollIntervalId);this._fire("done",duration);return duration};Monitor.prototype._print=function(msg){if(this._debug){console.log(msg)}};function SwarmMonitor(swarm,opts){this._swarm=swarm;this._lastStatus=undefined;this._statusChangeListeners=[];Monitor.call(this,this._swarmPoller,opts)}SwarmMonitor.prototype=GROK.util.heir(Monitor.prototype);SwarmMonitor.prototype.constructor=Monitor;SwarmMonitor.prototype._swarmPoller=function(cb){var me=this;this._print("polling for swarm...");this._swarm.getStatus(function(err,swarm){if(err){return me._fire("error",err)}var status=swarm.get("status");me._print("swarm status: "+status);if(status!==me._lastStatus){me.statusChange(swarm)}me._lastStatus=status;cb(swarm);if(status===GROK.Swarm.STATUS.COMPLETED){me.stop()}})};SwarmMonitor.prototype.onStatusChange=function(fn){this._statusChangeListeners.push({trigger:ANY,fn:fn})};SwarmMonitor.prototype.onStatus=function(status,fn){this._statusChangeListeners.push({trigger:status,fn:fn})};SwarmMonitor.prototype.statusChange=function(swarm){this._print("SwarmMonitor calling statusChange listeners");this._statusChangeListeners.forEach(function(listener){var trigger=listener.trigger,fn=listener.fn;if(trigger===ANY||trigger===swarm.get("status")){fn(swarm)}})};function PredictionMonitor(model,opts){opts=opts||{};this._getOutputDataOpts=opts.outputDataOptions||{limit:100,shift:true};this._model=model;this._dataListeners=[];this._lastRowIdSeen=opts.lastRowIdSeen||-1;Monitor.call(this,this._outputPoller,opts)}PredictionMonitor.prototype=GROK.util.heir(Monitor.prototype);PredictionMonitor.prototype.constructor=Monitor;PredictionMonitor.prototype._outputPoller=function(cb){var me=this;this._print("polling for new model output...");this._model.getOutputData(me._getOutputDataOpts,function(err,output){var newDataExists=false,unprocessedData,lastRowIdSeen=me._lastRowIdSeen;if(err){me._print(err);return me._fire("error",err)}unprocessedData=output.data.slice(1,output.data.length);output.data=me._processOutputData(output.data,output.meta);if(output.data.length&&lastRowIdSeen!==extractLastRowId(output)){newDataExists=true;me._lastNewDataTime=new Date}me._data(output,unprocessedData);me._lastPollTime=(new Date).getTime();cb(output,newDataExists)})};PredictionMonitor.prototype.onData=function(fn){this._dataListeners.push(fn)};PredictionMonitor.prototype._data=function(chunk,unProcessedChunk){this._print("notifying "+this._dataListeners.length+" listener of new data");this._dataListeners.forEach(function(listener){listener(chunk,unProcessedChunk)})};PredictionMonitor.prototype._processOutputData=function(data,meta){var me=this,startAt,result,secondsSinceLastNewData,dataOnly=data.slice(1,data.length),firstOutputRowId,lastOutputRowId;if(dataOnly.length===0||dataOnly[0].length===0){return[]}firstOutputRowId=dataOnly[0][0];lastOutputRowId=dataOnly[dataOnly.length-2][0];if(this._lastRowIdSeen===-1){result=dataOnly}else{if(firstOutputRowId<this._lastRowIdSeen){startAt=findIndex(dataOnly,function(row){return row[0]===me._lastRowIdSeen+1});if(!startAt){result=[]}else{result=dataOnly.slice(startAt)}}else if(firstOutputRowId+1===this._lastRowIdSeen){result=dataOnly}else{me._print("data gap");me._fire("error",new Error("There was a data gap while retrieving predictions from the API."));result=dataOnly}}if(this._lastRowIdSeen===lastOutputRowId){secondsSinceLastNewData=((new Date).getTime()-this._lastNewDataTime)/1e3;if(meta.modelStatus!=="swarming"&&secondsSinceLastNewData>this._timeout){this._print("timeout");this.stop()}}this._lastRowIdSeen=lastOutputRowId;return result};GROK.SwarmMonitor=SwarmMonitor;GROK.PredictionMonitor=PredictionMonitor})(window);